
* Org listcruncher

  # Note: The export of the org link with
  # file:https://travis....?branch=master fails to be recognized and
  # converted to a markdown image link. So I insert this directly.
  #+BEGIN_EXPORT md
  [![img](https://travis-ci.org/dfeich/org-listcruncher.svg?branch=master)](https://travis-ci.org/dfeich/org-listcruncher.svg?branch=master)
  #+END_EXPORT

  org-listcruncher provides a way to convert org-mode lists into
  a table structure following specific semantics. 

** Installation

   I will submit ist as a MELPA package.

   If you want to test it already, just clone this repository, make sure that it is
   in your emacs search path and load the package using

   #+BEGIN_SRC elisp
     (require 'org-listcruncher)
   #+END_SRC

** Example usage

   Write a planning list and give it a name using the appropriate Org syntax (e.g. =#+NAME: lstTest=).
   Here is an example

   #+NAME: lstTest
   - item: item X modified by replacing values (amount: 15, recurrence: 1, end-year: 2020)
     - modification of item X (amount: 20)
     - another modification of item X (other: 500)
       - modification of the modification (other: 299)
   - illustrating inheritance (recurrence: 2, end-year: 2024)
     - item: item A. Some longer explanation that may run over
       multiple lines (amount: 10)
     - item: item B (amount: 20)
     - item: item C (amount: 30)
       - a modification to item C (amount: 25, recurrence: 3)
   - item: item Y modified by operations (amount: 50, recurrence: 4, end-year: 2026)
     - modification by an operation (amount: +50)
     - modification by an operation (amount: *1.5)
   - item: item Z entered in scientific format (amount: 1e3, recurrence: 3, end-year: 2025)
     - modification by an operation (amount: -1e2)

   We can use org-listcruncher to convert this list into a table   

   #+NAME: src-example1
   #+BEGIN_SRC elisp :results value :var listname="lstTest" :exports both
     (org-listcruncher-to-table listname)
   #+END_SRC

   #+RESULTS: src-example1
   | description                         | other | amount | recurrence | end-year |
   |-------------------------------------+-------+--------+------------+----------|
   | item X modified by replacing values |   299 |     20 |          1 |     2020 |
   | item A                              |       |     10 |          2 |     2024 |
   | item B                              |       |     20 |          2 |     2024 |
   | item C                              |       |     25 |          3 |     2024 |
   | item Y modified by operations       |       |  150.0 |          4 |     2026 |
   | item Z entered in scientific format |       |  900.0 |          3 |     2025 |

   
   The rules for writing such a planning list are
   1. Each line contains a tag defining wheter the line will become a table row. For this
      example I defined this as the string "item:". Rows without such a tag just serve as
      metadata.
   2. A string following the output tag "item:" is taken as the description of the table row.
   3. Each line can contain any number of key/value pairs in parentheses in the form
       =(key1: val1, key2: val2, ...)=
   4. Lines of lower hierarchical order in the list inherit their default settings for key/values
      from the upper items.
   5. The key value of a higher order item can be overwritten by a new new value for the same key
      in a lower order line.
   6. If a given value is of the form +10, -10, /10, *10, i.e. an operator followed by a number,
      the operation is carried out on the previous value of the respective key.


   We can also provide an additional argument to affect the order of
   columns in which the table is produced.
   #+BEGIN_SRC elisp :results value :var listname="lstTest" :exports both
     (org-listcruncher-to-table listname '("description" "amount" "recurrence"))
   #+END_SRC

   #+RESULTS:
   | description                         | amount | recurrence | other | end-year |
   |-------------------------------------+--------+------------+-------+----------|
   | item X modified by replacing values |     20 |          1 |   299 |     2020 |
   | item A                              |     10 |          2 |       |     2024 |
   | item B                              |     20 |          2 |       |     2024 |
   | item C                              |     25 |          3 |       |     2024 |
   | item Y modified by operations       |  150.0 |          4 |       |     2026 |
   | item Z entered in scientific format |  900.0 |          3 |       |     2025 |



   It is also possible to directly obtain single table field values based on defining the
   row and column through the string corresponding to an item's description and its
   column name:
   
   #+BEGIN_SRC elisp :results value :var listname="lstTest" :exports both
     (org-listcruncher-get-field listname "item B" "amount")
   #+END_SRC

   #+RESULTS:
   : 20
   
** Tests                                                           :noexport:

   A look at the main heavy lifting function and its return values:
   #+BEGIN_SRC elisp :results output :var listname="lstTest"
     (pp (org-listcruncher--parselist (save-excursion
				       (goto-char (point-min))
				       (unless (search-forward-regexp (concat  "^ *#\\\+NAME: .*" listname) nil t)
					 (error "No list of this name found: %s" listname))
				       (forward-line 1)
				       (org-list-to-lisp))
				     nil
				     nil))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ((("amount" "-1e2")
     ("amount" "1e3")
     ("recurrence" "3")
     ("end-year" "2025")
     ("amount" "*1.5")
     ("amount" "+50")
     ("amount" "50")
     ("recurrence" "4")
     ("end-year" "2026")
     ("amount" "25")
     ("recurrence" "3")
     ("amount" "30")
     ("amount" "20")
     ("amount" "10")
     ("recurrence" "2")
     ("end-year" "2024")
     ("other" "299")
     ("other" "500")
     ("amount" "20")
     ("amount" "15")
     ("recurrence" "1")
     ("end-year" "2020"))
    ((("description" "item X modified by replacing values")
      ("other" "299")
      ("other" "500")
      ("amount" "20")
      ("amount" "15")
      ("recurrence" "1")
      ("end-year" "2020"))
     (("description" "item A")
      ("amount" "10")
      ("recurrence" "2")
      ("end-year" "2024"))
     (("description" "item B")
      ("amount" "20")
      ("recurrence" "2")
      ("end-year" "2024"))
     (("description" "item C")
      ("amount" "25")
      ("recurrence" "3")
      ("amount" "30")
      ("recurrence" "2")
      ("end-year" "2024"))
     (("description" "item Y modified by operations")
      ("amount" "*1.5")
      ("amount" "+50")
      ("amount" "50")
      ("recurrence" "4")
      ("end-year" "2026"))
     (("description" "item Z entered in scientific format")
      ("amount" "-1e2")
      ("amount" "1e3")
      ("recurrence" "3")
      ("end-year" "2025"))))
   #+end_example



* Tests integrating with orgbabelhelper                            :noexport:

  
  #+BEGIN_SRC python :results output raw drawer :var tbl=src-example1 :colnames no
    import orgbabelhelper as obh

    df = obh.orgtable_to_dataframe(tbl, index="description")
    print(obh.dataframe_to_orgtable(df, caption="Example 1"))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+CAPTION: Example 1
  |description|other|amount|recurrence|end-year|
  |-----
  |item X modified by replacing values|299|20|1|2020|
  |item A||10|2|2024|
  |item B||20|2|2024|
  |item C||25|3|2024|
  |item Y modified by operations||150.0|4|2026|
  |item Z entered in scientific format||900.0|3|2025|

  :END:

* COMMENT Org Babel settings
Local variables:
org-confirm-babel-evaluate: nil
End:
